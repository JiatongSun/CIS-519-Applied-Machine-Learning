# -*- coding: utf-8 -*-
"""hw0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZVRjSJsB5aXAe0NNF1tHvDnSBQ4__GfH

#CIS 419/519 HW0 iPython Notebook

Complete the answers to Questions 5 and 6 by completing this notebook.

# 5.) Dynamic Programming
"""

import numpy as np
def CompletePath(s, w, h) -> str:
    '''This function is used to escape from a room whose size is w * h.
    You are trapped in the bottom-left corner and need to cross to the
    door in the upper-right corner to escape.
    @:param s: a string representing the partial path composed of {'U', 'D', 'L', 'R', '?'}
    @:param w: an integer representing the room width
    @:param h: an integer representing the room length
    @:return path: a string that represents the completed path, with all question marks in with the correct directions
    or None if there is no path possible.
    '''

    # # TODO # #
    # error-check
    assert isinstance(s,str), "s is not a string!"
    assert isinstance(w,int), "w is not an integer!"
    assert isinstance(h,int), "h is not an integer!"
    
    # function
    ori = {'U':(0,1),'D':(0,-1),'L':(-1,0),'R':(1,0),"?":(0,0)}
    choice = "UDLR"
    start = (0,0)                               # the start coordinate
    y, x = start
    used = np.zeros((h, w), dtype = np.int32)   # document passed coordinates
    used[y][x] = 1                              # the start coordinate is passed
    idx = 0                                     # the index of the string
    for i in s:
        dx,dy = ori[i]
        if not(dx==0 and dy==0):                # the path is not "?"
            x, y = x + dx, y + dy               # new coordinate
            # return if out of range
            if x<0 or x>w-1 or y<0 or y>h-1 or used[y][x]==1:
                return
            else:
                used[y][x] = 1                  # current coordinate used
                
            # judge the result path
            if x == w-1 and y == h-1:
                if idx == len(s)-1:
                    return s
                else:
                    continue
            elif idx == len(s)-1:
                continue
            else:
                idx = idx + 1                   # continue the path
        else:                                   # the path is "?"
            # enumerate 4 directions
            for j in choice:
                try_s = s[:idx] + j + s[idx+1:] # guess the first "?"
                sol = CompletePath(try_s,w,h)   # solve the path based on guess
                if sol:
                    return sol
                else:
                    continue

"""# 6.) Pandas Data Manipulation

In this section, we use the `Pandas` package to carry out 3 common data manipulation tasks :

* **Calculate missing ratios of variables**
* **Create numerical binary variables**
* **Convert categorical variables using one-hot encoding**

For the exercise, we will be using the Titanic dataset, the details of which can be found [here](https://www.kaggle.com/c/titanic/overview). For each of the data manipulation tasks, we have defined a skeleton for the python functions that carry out the given the manipulation. Using the function documentation, fill in the functions to implement the data manipulation.
"""

import pandas as pd
import numpy as np

"""**Dataset Link** : https://github.com/rsk2327/CIS519/blob/master/train.csv


The file can be downloaded by navigating to the above link, clicking on the 'Raw' option and then saving the file.

Linux/Mac users can use the `wget` command to download the file directly. This can be done by running the following code in a Jupyter notebook cell

```
!wget https://github.com/rsk2327/CIS519/blob/master/train.csv
```
"""

# Read in the datafile using Pandas

# df = ...            # # TODO # #

def getMissingRatio(inputDf):
    """
    Returns the percentage of missing values in each feature of the dataset.
    
    Ensure that the output dataframe has the column names: Feature, MissingPercent

    Args:
        inputDf (Pandas.DataFrame): Dataframe to be evaluated


    Returns:
        outDf (Pandas.DataFrame): Resultant dataframe with 2 columns (Feature, MissingPercent)
                                  Each row corresponds to one of the features in `inputDf`

    """
    
    
    ## TODO ##
    outSeries = inputDf.isna().mean()                 # calculate missing ratios
    outDf = pd.DataFrame({'Feature':outSeries.index, 'MissingPercent':outSeries.values})
    
    return outDf

def convertToBinary(inputDf, feature):
    """
    Converts a two-value (binary) categorical feature into a numerical 0-1 representation and appends it to the dataframe
    
    Args:
        inputDf (pandas.DataFrame): Input dataframe
        variable (str) : Categorical feature which has to be converted into a numerical (0-1) representation
        
    Returns:
        outDf : Resultant dataframe with the original two-value categorical feature replaced by a numerical 0-1 feature

    """
    
    ## TODO ##
    if feature not in inputDf.columns:
        raise ValueError('not a feature')
        return
    inputCol = inputDf[feature]
    if inputCol.isna().sum() > 0:
        raise ValueError('cannot convert')
        return
    firstVal = inputDf.loc[0,feature]
    for i in range(len(inputCol)):
        if inputCol.loc[i] != firstVal:
            secondVal = inputCol.loc[i]
            break
    outDf=pd.DataFrame(index=inputDf[feature].index,columns=[feature])
    outDf[inputCol == firstVal] = 1
    outDf[inputCol == secondVal] = 0
    if outDf[feature].isna().sum() > 0:
        raise ValueError('not a binary feature')
        return
    
    return outDf

def addDummyFeatures(inputDf, feature):
    """
    Create a one-hot-encoded version of a categorical feature and append it to the existing 
    dataframe.
    
    After one-hot encoding the categorical feature, ensure that the original categorical feature is dropped
    from the dataframe so that only the one-hot-encoded features are retained.
    
    For more on one-hot encoding (OHE) : https://hackernoon.com/what-is-one-hot-encoding-why-and-when-do-you-have-to-use-it-e3c6186d008f

    Arguments:
        inputDf (Pandas.DataFrame): input dataframe
        feature (str) : Feature for which the OHE is to be performed


    Returns:
        outDf (Pandas.DataFrame): Resultant dataframe with the OHE features appended and the original feature removed

    """
    
    
    ## TODO ##
    if feature not in inputDf.columns:
        raise ValueError('not a feature')
        return
    outDf =  (pd.concat([inputDf,pd.get_dummies(inputDf[feature],\
                        prefix=feature)],axis=1)).drop(feature,axis=1)
    
    return outDf